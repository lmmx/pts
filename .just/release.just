# Rust release workflow using release-plz
ship:
    #!/usr/bin/env -S echo-comment --shell-flags="-euo pipefail" --color="\\033[38;5;202m"

    # ðŸ” Refuse to run if not on master branch or not up to date with origin/master
    branch="$(git rev-parse --abbrev-ref HEAD)"
    if [[ "$branch" != "master" ]]; then
        # âŒ Refusing to run: not on 'master' branch (current: $branch)
        exit 1
    fi
    # ðŸ” Fetch master branch
    git fetch origin master
    local_rev="$(git rev-parse HEAD)"
    remote_rev="$(git rev-parse origin/master)"
    # ðŸ” Local: $local_rev\nðŸ” Remote: $remote_rev
    if [[ "$local_rev" != "$remote_rev" ]]; then
        # âŒ Refusing to run: local master branch is not up to date with origin/master
        # Local HEAD:  $local_rev
        # Origin HEAD: $remote_rev
        # Please pull/rebase to update.
        exit 1
    fi

    # ðŸ” Dry-run release...
    just publish --dry-run
    # âœ… Dry-run went OK, proceeding to real release
    
    # ðŸ¦€ Update Cargo.toml versions and changelogs
    release-plz update
    git add .
    # Run a pre-precommit lint pass to avoid the linter halting our release!
    just precommit || true
    git commit -m "chore(release): ðŸ¦€ Upgrades"
    # Note: if already pushed you would just need to revert the additions (delete changelogs)

    # ðŸ¦€ Run prepush only for the Rust crates we are releasing
    just prepush
    # ðŸš€ Push the version bump commit
    git push --no-verify

    # ðŸ“¦ Create releases and tags
    just publish

publish mode="":
    #!/usr/bin/env -S bash -euo pipefail
    git_token=$(gh auth token 2>/dev/null) || git_token=$PUBLISH_GITHUB_TOKEN

    ## ðŸ¦€ Let release-plz handle workspace crate tagging
    ## It will create tags like: genson-core-v0.2.1, genson-cli-v0.1.5, etc.
    release-plz release --backend github --git-token $git_token {{mode}}
